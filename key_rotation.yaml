AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS Key Rotation System'

Parameters:
  RotationInterval:
    Type: Number
    Default: 10
    Description: 'Interval in minutes for key rotation'
  
  DeactivationInterval:
    Type: Number
    Default: 12
    Description: 'Interval in minutes for key deactivation'
  
  DeletionInterval:
    Type: Number
    Default: 15
    Description: 'Interval in minutes for key deletion'
  
  SenderEmail:
    Type: String
    Description: 'Email address for sending notifications'

Resources:
  KeyRotationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: iam-key-rotation-KeyRotationFunction-tSqkEMN96R3N
      Handler: index.handler
      Role: !GetAtt KeyRotationRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import time
          from datetime import datetime, timedelta
          import os
          import logging
          
          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def mask_secret(secret):
              """Mask a secret string, showing only first 4 and last 4 characters."""
              if len(secret) <= 8:
                  return '*' * len(secret)
              return secret[:4] + '*' * (len(secret) - 8) + secret[-4:]
          
          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              iam = boto3.client('iam')
              secrets = boto3.client('secretsmanager')
              ses = boto3.client('ses')
              
              # Check if this is an API Gateway event
              if 'path' in event:
                  return handle_api_request(event, context)
              
              # This is a scheduled event
              try:
                  # Parse the event input
                  if isinstance(event.get('detail', {}).get('input'), str):
                      event_input = json.loads(event['detail']['input'])
                  elif isinstance(event.get('input'), str):
                      event_input = json.loads(event['input'])
                  else:
                      event_input = event.get('input', {})
                  
                  action = event_input.get('action', 'rotate')
                  logger.info(f"Processing scheduled action: {action}")
                  
                  # Get all secrets
                  secrets_list = secrets.list_secrets()
                  logger.info(f"Found {len(secrets_list['SecretList'])} secrets")
                  
                  for secret in secrets_list['SecretList']:
                      if not secret['Name'].startswith('test-user-'):
                          continue
                          
                      try:
                          # Get secret value
                          secret_value = json.loads(secrets.get_secret_value(SecretId=secret['Name'])['SecretString'])
                          created_date = datetime.strptime(secret_value['CreatedDate'], '%Y-%m-%dT%H:%M:%SZ')
                          current_time = datetime.utcnow()
                          
                          logger.info(f"Processing secret {secret['Name']} with created_date {created_date}")
                          
                          if action == 'rotate':
                              # Check if rotation is needed (every 10 minutes)
                              time_diff = (current_time - created_date).total_seconds() / 60
                              logger.info(f"Time since last rotation: {time_diff} minutes")
                              
                              if time_diff >= 10:
                                  username = secret['Name']
                                  email = secret_value['Email']
                                  
                                  logger.info(f"Creating new access key for {username}")
                                  
                                  # Create new access key
                                  new_key = iam.create_access_key(UserName=username)
                                  
                                  # Store new credentials
                                  new_secret_value = {
                                      'AccessKeyId': new_key['AccessKey']['AccessKeyId'],
                                      'SecretAccessKey': new_key['AccessKey']['SecretAccessKey'],
                                      'CreatedDate': current_time.strftime('%Y-%m-%dT%H:%M:%SZ'),
                                      'Email': email,
                                      'OldAccessKeyId': secret_value['AccessKeyId']  # Store old key for deactivation
                                  }
                                  
                                  secrets.update_secret(
                                      SecretId=username,
                                      SecretString=json.dumps(new_secret_value)
                                  )
                                  
                                  logger.info(f"Updated secret for {username}")
                                  
                                  # Send email notification
                                  if email:
                                      ses.send_email(
                                          Source='krishank.kaushik.1@gmail.com',
                                          Destination={'ToAddresses': [email]},
                                          Message={
                                              'Subject': {'Data': f'AWS Credentials Rotated for {username}'},
                                              'Body': {'Text': {'Data': f"""
                                              Hello,
                                              
                                              Your AWS credentials have been rotated.
                                              
                                              New Access Key ID: {mask_secret(new_key['AccessKey']['AccessKeyId'])}
                                              New Secret Access Key: {mask_secret(new_key['AccessKey']['SecretAccessKey'])}
                                              
                                              For security reasons, only a portion of your credentials is shown.
                                              Please use the API endpoint to retrieve your full credentials when needed.
                                              
                                              The old key will be deactivated in 12 minutes and deleted in 15 minutes.
                                              
                                              Best regards,
                                              AWS Key Rotation System
                                              """}}
                                          }
                                      )
                                      logger.info(f"Sent rotation notification to {email}")
                          
                          elif action == 'deactivate':
                              # Deactivate old key if it exists
                              if 'OldAccessKeyId' in secret_value:
                                  try:
                                      logger.info(f"Deactivating old key for {secret['Name']}")
                                      iam.update_access_key(
                                          UserName=secret['Name'],
                                          AccessKeyId=secret_value['OldAccessKeyId'],
                                          Status='Inactive'
                                      )
                                      logger.info(f"Deactivated old key for {secret['Name']}")
                                      
                                      # Send email notification
                                      if secret_value['Email']:
                                          ses.send_email(
                                              Source='krishank.kaushik.1@gmail.com',
                                              Destination={'ToAddresses': [secret_value['Email']]},
                                              Message={
                                                  'Subject': {'Data': f'AWS Credentials Deactivated for {secret["Name"]}'},
                                                  'Body': {'Text': {'Data': f"""
                                                  Hello,
                                                  
                                                  Your old AWS credentials have been deactivated.
                                                  
                                                  The deactivated key will be deleted in 3 minutes.
                                                  
                                                  Best regards,
                                                  AWS Key Rotation System
                                                  """}}
                                              }
                                          )
                                          logger.info(f"Sent deactivation notification to {secret_value['Email']}")
                                  except Exception as e:
                                      logger.error(f"Error deactivating key for {secret['Name']}: {str(e)}")
                          
                          elif action == 'delete':
                              # Delete old key if it exists
                              if 'OldAccessKeyId' in secret_value:
                                  try:
                                      logger.info(f"Deleting old key for {secret['Name']}")
                                      iam.delete_access_key(
                                          UserName=secret['Name'],
                                          AccessKeyId=secret_value['OldAccessKeyId']
                                      )
                                      logger.info(f"Deleted old key for {secret['Name']}")
                                      
                                      # Remove OldAccessKeyId from secret
                                      secret_value.pop('OldAccessKeyId', None)
                                      secrets.update_secret(
                                          SecretId=secret['Name'],
                                          SecretString=json.dumps(secret_value)
                                      )
                                      
                                      # Send email notification
                                      if secret_value['Email']:
                                          ses.send_email(
                                              Source='krishank.kaushik.1@gmail.com',
                                              Destination={'ToAddresses': [secret_value['Email']]},
                                              Message={
                                                  'Subject': {'Data': f'AWS Credentials Deleted for {secret["Name"]}'},
                                                  'Body': {'Text': {'Data': f"""
                                                  Hello,
                                                  
                                                  Your old AWS credentials have been deleted.
                                                  
                                                  Best regards,
                                                  AWS Key Rotation System
                                                  """}}
                                              }
                                          )
                                          logger.info(f"Sent deletion notification to {secret_value['Email']}")
                                  except Exception as e:
                                      logger.error(f"Error deleting key for {secret['Name']}: {str(e)}")
                      except Exception as e:
                          logger.error(f"Error processing secret {secret['Name']}: {str(e)}")
                          continue
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(f'Key {action} completed')
                  }
              except Exception as e:
                  logger.error(f"Error handling scheduled event: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': 'Internal server error'})
                  }
          
          def handle_api_request(event, context):
              logger.info(f"Handling API request: {json.dumps(event)}")
              
              iam = boto3.client('iam')
              secrets = boto3.client('secretsmanager')
              ses = boto3.client('ses')
              
              # Add CORS headers
              headers = {
                  'Access-Control-Allow-Origin': '*',
                  'Access-Control-Allow-Headers': 'Content-Type,X-API-Key',
                  'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
              }
              
              # Handle OPTIONS request for CORS
              if event.get('httpMethod') == 'OPTIONS':
                  return {
                      'statusCode': 200,
                      'headers': headers,
                      'body': ''
                  }
              
              try:
                  # Validate API key
                  api_key = event.get('headers', {}).get('x-api-key')
                  if not api_key:
                      return {
                          'statusCode': 401,
                          'headers': headers,
                          'body': json.dumps({'error': 'API key is required'})
                      }
                  
                  # Get stored API key from Secrets Manager
                  try:
                      stored_api_key = json.loads(secrets.get_secret_value(SecretId='key-rotation-api-key')['SecretString'])['api_key']
                  except Exception as e:
                      logger.error(f"Error getting stored API key: {str(e)}")
                      return {
                          'statusCode': 500,
                          'headers': headers,
                          'body': json.dumps({'error': 'Internal server error'})
                      }
                  
                  # Validate API key
                  if api_key != stored_api_key:
                      return {
                          'statusCode': 403,
                          'headers': headers,
                          'body': json.dumps({'error': 'Invalid API key'})
                      }
                  
                  path = event['path']
                  http_method = event['httpMethod']
                  
                  logger.info(f"Processing {http_method} request for path: {path}")
                  
                  if path == '/export-credentials' and http_method == 'POST':
                      # Export all credentials
                      secrets_list = secrets.list_secrets()
                      credentials = {}
                      
                      for secret in secrets_list['SecretList']:
                          if not secret['Name'].startswith('test-user-'):
                              continue
                              
                          secret_value = json.loads(secrets.get_secret_value(SecretId=secret['Name'])['SecretString'])
                          credentials[secret['Name']] = {
                              'AccessKeyId': secret_value['AccessKeyId'],
                              'SecretAccessKey': secret_value['SecretAccessKey']
                          }
                      
                      return {
                          'statusCode': 200,
                          'headers': headers,
                          'body': json.dumps(credentials)
                      }
                  
                  elif path.startswith('/credentials/') and http_method == 'GET':
                      # Get credentials for a specific user
                      username = path.split('/')[-1]
                      
                      try:
                          secret_value = json.loads(secrets.get_secret_value(SecretId=username)['SecretString'])
                          return {
                              'statusCode': 200,
                              'headers': headers,
                              'body': json.dumps({
                                  'AccessKeyId': secret_value['AccessKeyId'],
                                  'SecretAccessKey': secret_value['SecretAccessKey']
                              })
                          }
                      except secrets.exceptions.ResourceNotFoundException:
                          return {
                              'statusCode': 404,
                              'headers': headers,
                              'body': json.dumps({'error': 'User not found'})
                          }
                      except Exception as e:
                          logger.error(f"Error getting credentials for {username}: {str(e)}")
                          return {
                              'statusCode': 500,
                              'headers': headers,
                              'body': json.dumps({'error': 'Internal server error'})
                          }
                  
                  elif path.startswith('/credentials/') and http_method == 'POST':
                      # Create new credentials for a specific user
                      username = path.split('/')[-1]
                      
                      try:
                          # Create new access key
                          new_key = iam.create_access_key(UserName=username)
                          access_key = new_key['AccessKey']['AccessKeyId']
                          secret_key = new_key['AccessKey']['SecretAccessKey']
                          
                          # Store in Secrets Manager
                          secret_value = {
                              'AccessKeyId': access_key,
                              'SecretAccessKey': secret_key,
                              'CreatedDate': datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
                              'Email': secrets.get_secret_value(SecretId=username)['SecretString'].get('Email', '')
                          }
                          
                          secrets.update_secret(
                              SecretId=username,
                              SecretString=json.dumps(secret_value)
                          )
                          
                          # Send email with masked credentials
                          if secret_value['Email']:
                              ses.send_email(
                                  Source='krishank.kaushik.1@gmail.com',
                                  Destination={'ToAddresses': [secret_value['Email']]},
                                  Message={
                                      'Subject': {'Data': f'New AWS Credentials for {username}'},
                                      'Body': {'Text': {'Data': f"""
                                      Hello,

                                      New AWS credentials have been created for your account.
                                      For security reasons, the credentials are not included in this email.

                                      To access your credentials, please use the API endpoint provided in your initial setup email.

                                      Important Security Notes:
                                      1. Keep these credentials secure and never share them
                                      2. The system will automatically rotate your keys every 10 minutes
                                      3. You will receive email notifications for key rotation events
                                      4. Old keys will be automatically deactivated after 12 minutes
                                      5. Deactivated keys will be deleted after 15 minutes

                                      If you have any questions, please contact your system administrator.

                                      Best regards,
                                      AWS Key Rotation System
                                      """}}
                                  }
                              )
                          
                          return {
                              'statusCode': 200,
                              'headers': headers,
                              'body': json.dumps({
                                  'AccessKeyId': access_key,
                                  'SecretAccessKey': secret_key
                              })
                          }
                      except Exception as e:
                          logger.error(f"Error creating credentials for {username}: {str(e)}")
                          return {
                              'statusCode': 500,
                              'headers': headers,
                              'body': json.dumps({'error': 'Internal server error'})
                          }
                  
                  else:
                      return {
                          'statusCode': 400,
                          'headers': headers,
                          'body': json.dumps({'error': 'Invalid request'})
                      }
                      
              except Exception as e:
                  logger.error(f"Error handling API request: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': headers,
                      'body': json.dumps({'error': 'Internal server error'})
                  }
      Runtime: python3.9
      Timeout: 900
      Environment:
        Variables:
          SENDER_EMAIL: !Ref SenderEmail

  KeyRotationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: KeyRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:CreateAccessKey
                  - iam:DeleteAccessKey
                  - iam:UpdateAccessKey
                  - iam:ListAccessKeys
                  - iam:GetUser
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:UpdateSecret
                  - secretsmanager:ListSecrets
                Resource: '*'
              - Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: '*'

  KeyRotationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Schedule for key rotation'
      ScheduleExpression: rate(10 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt KeyRotationFunction.Arn
          Id: KeyRotationFunction
          Input: '{"action": "rotate"}'

  KeyDeactivationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Schedule for key deactivation'
      ScheduleExpression: rate(12 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt KeyRotationFunction.Arn
          Id: KeyRotationFunction
          Input: '{"action": "deactivate"}'

  KeyDeletionSchedule:
    Type: AWS::Events::Rule
    Properties:
      Description: 'Schedule for key deletion'
      ScheduleExpression: rate(15 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt KeyRotationFunction.Arn
          Id: KeyRotationFunction
          Input: '{"action": "delete"}'

  KeyRotationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt KeyRotationSchedule.Arn

  KeyDeactivationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt KeyDeactivationSchedule.Arn

  KeyDeletionPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt KeyDeletionSchedule.Arn

Outputs:
  KeyRotationFunction:
    Description: 'Lambda function for key rotation'
    Value: !GetAtt KeyRotationFunction.Arn
  KeyRotationSchedule:
    Description: 'EventBridge rule for key rotation'
    Value: !GetAtt KeyRotationSchedule.Arn
  KeyDeactivationSchedule:
    Description: 'EventBridge rule for key deactivation'
    Value: !GetAtt KeyDeactivationSchedule.Arn
  KeyDeletionSchedule:
    Description: 'EventBridge rule for key deletion'
    Value: !GetAtt KeyDeletionSchedule.Arn 