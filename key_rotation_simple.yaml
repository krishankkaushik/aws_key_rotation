AWSTemplateFormatVersion: '2010-09-09'
Description: 'IAM Key Rotation with 10-minute rotation period'

Parameters:
  SenderEmail:
    Type: String
    Description: 'Sender email address for notifications'
  
  AdminEmail:
    Type: String
    Description: 'Admin email address for notifications'

Resources:
  KeyRotationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: KeyRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:CreateAccessKey
                  - iam:DeleteAccessKey
                  - iam:ListAccessKeys
                  - iam:UpdateAccessKey
                  - iam:GetUser
                  - iam:ListUserTags
                  - iam:ListUsers
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  - secretsmanager:PutSecretValue
                  - secretsmanager:DescribeSecret
                  - secretsmanager:CreateSecret
                  - secretsmanager:UpdateSecret
                  - secretsmanager:DeleteSecret
                  - secretsmanager:TagResource
                  - secretsmanager:UntagResource
                  - secretsmanager:ListSecrets
                Resource: 
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:user/*'
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${AWS::StackName}-*'
              - Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: '*'

  KeyRotationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role: !GetAtt KeyRotationRole.Arn
      Runtime: python3.9
      Timeout: 300
      Environment:
        Variables:
          SENDER_EMAIL: !Ref SenderEmail
          ADMIN_EMAIL: !Ref AdminEmail
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import time
          from datetime import datetime, timezone
          from botocore.exceptions import ClientError
          
          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")
                  
                  # Initialize AWS clients
                  iam = boto3.client('iam')
                  secrets = boto3.client('secretsmanager')
                  
                  # Check if this is an API request
                  if 'queryStringParameters' in event and event['queryStringParameters']:
                      username = event['queryStringParameters'].get('username')
                      if not username:
                          return {
                              'statusCode': 400,
                              'body': json.dumps({'error': 'Username parameter is required'})
                          }
                      
                      # Get credentials from Secrets Manager
                      try:
                          secret_id = f'user/{username}/credentials'
                          response = secrets.get_secret_value(SecretId=secret_id)
                          credentials = json.loads(response['SecretString'])
                          
                          # Check if credentials are still active
                          if credentials.get('status') == 'active':
                              return {
                                  'statusCode': 200,
                                  'body': json.dumps({
                                      'AccessKeyId': credentials['AccessKeyId'],
                                      'SecretAccessKey': credentials['SecretAccessKey']
                                  })
                              }
                          else:
                              return {
                                  'statusCode': 404,
                                  'body': json.dumps({'error': 'No active credentials found'})
                              }
                      except secrets.exceptions.ResourceNotFoundException:
                          return {
                              'statusCode': 404,
                              'body': json.dumps({'error': 'No credentials found for user'})
                          }
                  
                  # If not an API request, proceed with key rotation
                  logger.info("Starting key rotation process")
                  users = iam.list_users()['Users']
                  logger.info(f"Found {len(users)} users to process")
                  
                  for user in users:
                      username = user['UserName']
                      logger.info(f"Processing user: {username}")
                      
                      existing_keys = iam.list_access_keys(UserName=username)['AccessKeyMetadata']
                      logger.info(f"Found {len(existing_keys)} existing keys for user {username}")
                      
                      # Get active keys
                      active_keys = [k for k in existing_keys if k['Status'] == 'Active']
                      logger.info(f"Found {len(active_keys)} active keys for user {username}")
                      
                      current_time = datetime.now(timezone.utc)
                      secret_id = f'user/{username}/credentials'
                      
                      # First, deactivate old keys
                      for key in active_keys:
                          key_age = (current_time - key['CreateDate']).total_seconds() / 60
                          logger.info(f"Key {key['AccessKeyId']} age: {key_age} minutes")
                          
                          if key_age >= 10:  # 10 minutes
                              logger.info(f"Deactivating key {key['AccessKeyId']} for user {username}")
                              iam.update_access_key(
                                  UserName=username,
                                  AccessKeyId=key['AccessKeyId'],
                                  Status='Inactive'
                              )
                              
                              # Update status in Secrets Manager
                              try:
                                  response = secrets.get_secret_value(SecretId=secret_id)
                                  credentials = json.loads(response['SecretString'])
                                  if credentials['AccessKeyId'] == key['AccessKeyId']:
                                      credentials['status'] = 'inactive'
                                      secrets.update_secret(
                                          SecretId=secret_id,
                                          SecretString=json.dumps(credentials)
                                      )
                                      logger.info(f"Updated secret status to inactive for key {key['AccessKeyId']}")
                              except ClientError as e:
                                  logger.error(f"Error updating secret status: {str(e)}")
                      
                      # Then, delete very old keys
                      for key in existing_keys:
                          key_age = (current_time - key['CreateDate']).total_seconds() / 60
                          if key_age >= 13:  # 13 minutes
                              logger.info(f"Deleting old key {key['AccessKeyId']} for user {username}")
                              iam.delete_access_key(
                                  UserName=username,
                                  AccessKeyId=key['AccessKeyId']
                              )
                              
                              # Delete from Secrets Manager if it's the old key
                              try:
                                  response = secrets.get_secret_value(SecretId=secret_id)
                                  credentials = json.loads(response['SecretString'])
                                  if credentials['AccessKeyId'] == key['AccessKeyId']:
                                      try:
                                          secrets.delete_secret(
                                              SecretId=secret_id,
                                              ForceDeleteWithoutRecovery=True
                                          )
                                          logger.info(f"Deleted secret for old key {key['AccessKeyId']}")
                                          # Wait a moment for the deletion to complete
                                          time.sleep(1)
                                      except secrets.exceptions.ResourceNotFoundException:
                                          logger.info(f"Secret {secret_id} already deleted")
                              except ClientError as e:
                                  logger.error(f"Error deleting secret: {str(e)}")
                      
                      # Finally, create new key if needed
                      active_keys = [k for k in iam.list_access_keys(UserName=username)['AccessKeyMetadata'] if k['Status'] == 'Active']
                      if len(active_keys) < 2:
                          logger.info(f"Creating new key for user {username}")
                          new_key = iam.create_access_key(UserName=username)['AccessKey']
                          
                          # Store in Secrets Manager
                          secret_value = {
                              'AccessKeyId': new_key['AccessKeyId'],
                              'SecretAccessKey': new_key['SecretAccessKey'],
                              'CreateDate': new_key['CreateDate'].isoformat(),
                              'status': 'active'
                          }
                          
                          try:
                              # Try to create new secret
                              secrets.create_secret(
                                  Name=secret_id,
                                  SecretString=json.dumps(secret_value),
                                  Description=f'Credentials for user {username}'
                              )
                              logger.info(f"Created new secret for user {username}")
                          except secrets.exceptions.ResourceExistsException:
                              # If secret exists, update it
                              secrets.update_secret(
                                  SecretId=secret_id,
                                  SecretString=json.dumps(secret_value)
                              )
                              logger.info(f"Updated existing secret for user {username}")
                          except ClientError as e:
                              if "scheduled for deletion" in str(e):
                                  # If secret is scheduled for deletion, wait and retry
                                  logger.info(f"Secret {secret_id} is scheduled for deletion, waiting...")
                                  time.sleep(2)
                                  try:
                                      secrets.create_secret(
                                          Name=secret_id,
                                          SecretString=json.dumps(secret_value),
                                          Description=f'Credentials for user {username}'
                                      )
                                      logger.info(f"Created new secret for user {username} after waiting")
                                  except ClientError as e2:
                                      logger.error(f"Error creating secret after waiting: {str(e2)}")
                              else:
                                  logger.error(f"Error managing secret: {str(e)}")
                  
                  logger.info("Key rotation completed successfully")
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'Key rotation completed successfully'})
                  }
                  
              except Exception as e:
                  logger.error(f"Error during key rotation: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  KeyRotationSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub ${AWS::StackName}-rotation-schedule
      Description: "Triggers IAM key rotation every 10 minutes"
      ScheduleExpression: rate(10 minutes)
      State: ENABLED
      Targets:
        - Arn: !GetAtt KeyRotationFunction.Arn
          Id: KeyRotationTarget
          Input: '{"source": "scheduled-rotation"}'

  KeyRotationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt KeyRotationSchedule.Arn

  InitialRotationRule:
    Type: AWS::Events::Rule
    Properties:
      Name: InitialRotationRule
      Description: 'Trigger initial key rotation'
      EventPattern:
        source:
          - aws.cloudformation
        detail-type:
          - AWS CloudFormation Stack Status Change
        detail:
          stack-name:
            - !Ref AWS::StackName
          status-details:
            status:
              - CREATE_COMPLETE
              - UPDATE_COMPLETE
      State: ENABLED
      Targets:
        - Arn: !GetAtt KeyRotationFunction.Arn
          Id: InitialRotationFunction

  InitialRotationPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt InitialRotationRule.Arn

  KeyRotationApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: KeyRotationAPI
      Description: API for AWS IAM key rotation

  KeyRotationApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref KeyRotationApi
      ParentId: !GetAtt KeyRotationApi.RootResourceId
      PathPart: active-key

  KeyRotationApiMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref KeyRotationApi
      ResourceId: !Ref KeyRotationApiResource
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${KeyRotationFunction.Arn}/invocations
        RequestParameters:
          integration.request.querystring.username: method.request.querystring.username
      RequestParameters:
        method.request.querystring.username: true
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
        - StatusCode: 400
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
        - StatusCode: 404
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
        - StatusCode: 500
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  KeyRotationApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: KeyRotationApiMethod
    Properties:
      RestApiId: !Ref KeyRotationApi

  KeyRotationApiStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: KeyRotationApiDeployment
    Properties:
      RestApiId: !Ref KeyRotationApi
      DeploymentId: !Ref KeyRotationApiDeployment
      StageName: prod

  KeyRotationApiPermission:
    Type: AWS::Lambda::Permission
    DependsOn: KeyRotationApiStage
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref KeyRotationFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${KeyRotationApi}/*/*/*

  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    DependsOn: KeyRotationApiStage
    Properties:
      Name: !Sub ${AWS::StackName}-${AWS::Region}-api-key
      Description: API Key for accessing the key rotation API
      Enabled: true
      Value: !Sub ${AWS::StackName}-${AWS::Region}-${AWS::AccountId}

  UsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    DependsOn: 
      - KeyRotationApiStage
      - ApiKey
    Properties:
      Description: Usage plan for key rotation API
      ApiStages:
        - ApiId: !Ref KeyRotationApi
          Stage: prod
      Throttle:
        RateLimit: 100
        BurstLimit: 200
      Quota:
        Limit: 1000
        Period: DAY

  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    DependsOn: UsagePlan
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref UsagePlan

  ApiEndpointSecret:
    Type: AWS::SecretsManager::Secret
    DependsOn: KeyRotationApiStage
    Properties:
      Name: !Sub ${AWS::StackName}-${AWS::Region}-api-endpoint
      Description: API endpoint URL
      SecretString: !Sub '{"endpoint": "https://${KeyRotationApi}.execute-api.${AWS::Region}.amazonaws.com/prod/active-key"}'

Outputs:
  LambdaFunctionArn:
    Description: 'ARN of the Lambda function'
    Value: !GetAtt KeyRotationFunction.Arn
    Export:
      Name: KeyRotationLambdaArn

  EventRuleArn:
    Description: 'ARN of the EventBridge rule'
    Value: !GetAtt KeyRotationSchedule.Arn
    Export:
      Name: KeyRotationEventRuleArn

  ApiEndpoint:
    Description: 'API Gateway endpoint URL'
    Value: !Sub 'https://${KeyRotationApi}.execute-api.${AWS::Region}.amazonaws.com/prod/active-key'
    Export:
      Name: KeyRotationApiEndpoint

  ApiKey:
    Description: 'API Key for accessing the endpoint'
    Value: !Sub '${AWS::StackName}-${AWS::Region}-${AWS::AccountId}'
    Export:
      Name: KeyRotationApiKey 